<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Shift or Shoot</title>
    <style>
        body {
            background-color: #000;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: sans-serif;
        }
        canvas {
            border: 1px solid #fff;
            background-color: #000;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1120" height="600"></canvas>
    <script>
        // ----------------------------------------------------------------
        // --- Vector2D Math Helper ---
        // ----------------------------------------------------------------
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vector2(this.x - v.x, this.y - v.y); }
            multiply(scalar) { return new Vector2(this.x * scalar, this.y * scalar); }
            divide(scalar) { return new Vector2(this.x / scalar, this.y / scalar); }
            
            length() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            lengthSquared() { return this.x * this.x + this.y * this.y; }

            normalize() {
                const len = this.length();
                return len > 0 ? this.divide(len) : new Vector2();
            }

            dot(v) { return this.x * v.x + this.y * v.y; }
            cross(v) { return this.x * v.y - this.y * v.x; }

            rotate(angleDegrees) {
                const rad = angleDegrees * (Math.PI / 180);
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);
                return new Vector2(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
            }
            
            lerp(target, alpha) {
                return this.add(target.sub(this).multiply(alpha));
            }
            
            copy() { return new Vector2(this.x, this.y); }
        }

        // ----------------------------------------------------------------
        // --- Main Game Logic ---
        // ----------------------------------------------------------------
        class SosGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.mousePos = new Vector2();
                this.isMouseDown = false;
                
                this.SCREEN_WIDTH = 1120; this.SCREEN_HEIGHT = 600;
                this.CONTENT_WIDTH = 800; this.CONTENT_HEIGHT = 600;
                this.CONTENT_X_OFFSET = (this.SCREEN_WIDTH - this.CONTENT_WIDTH) / 2;
                
                this.BOARD_WIDTH = 700; this.BOARD_HEIGHT = 350;
                this.PLATE_SIZE = 80;
                this.WINNING_SCORE = 5;
                this.FPS = 60;
                this.TITLE_FADE_SPEED = 5;

                this.WHITE = 'rgb(255, 255, 255)';
                this.BLACK = 'rgb(0, 0, 0)';
                this.PLAYER_1_COLOR_RGB = { r: 20, g: 120, b: 220 };
                this.PLAYER_2_COLOR_RGB = { r: 220, g: 80, b: 80 };
                this.PLAYER_1_COLOR = `rgb(${this.PLAYER_1_COLOR_RGB.r}, ${this.PLAYER_1_COLOR_RGB.g}, ${this.PLAYER_1_COLOR_RGB.b})`;
                this.PLAYER_2_COLOR = `rgb(${this.PLAYER_2_COLOR_RGB.r}, ${this.PLAYER_2_COLOR_RGB.g}, ${this.PLAYER_2_COLOR_RGB.b})`;

                this.FRICTION_X = 0.96; this.FRICTION_Y = 0.96;
                this.ANGULAR_FRICTION = 0.98;
                this.POWER_MULTIPLIER = 0.12;

                this.SIDE_FRICTION = 0.7;
                this.STOP_THRESHOLD = 0.1;
                this.ANGULAR_STOP_THRESHOLD = 0.1;
                this.TORQUE_MULTIPLIER = 0.0018;
                this.COLLISION_ELASTICITY = 0.85;
                this.PLATE_INERTIA = (this.PLATE_SIZE ** 2) / 6;

                this.game_state = "LOADING";
                this.fade_alpha = 255;
                this.bgm_on = true; 
                this.se_on = true;
                this.assets = {};
                this.gameLoop = this.gameLoop.bind(this);
                
                this.init_game_session();
                this.loadAssets().then(() => {
                    this.create_buttons();
                    this.game_state = "FADE_IN_TO_TITLE";
                    this.assets.BGM.loop = true;
                    this.setupEventListeners();
                    requestAnimationFrame(this.gameLoop);
                });
            }

            init_game_session() {
                this.roulette_timer = 0;
                this.roulette_color = this.PLAYER_1_COLOR;
                this.roulette_sound_timer = 0;
                this.reset_game_vars();
            }

            reset_game_vars() {
                this.plates = [];
                this.scores = { 1: 0, 2: 0 };
                this.current_player = 1;
                this.selected_plate = null;
                this.drag_start_pos = null;
                this.click_offset = new Vector2(0, 0);
                this.score_popup_alpha = 0;
                this.victory_sound_played = false;
                // --- ▼▼▼ 変更点: 衝突音のクールダウン用タイマー ---
                this.last_collision_sound_time = 0;
            }

            async loadAssets() {
                const assetPaths = {
                    title_image: 'assets/title.png',
                    about1: 'assets/about1.png', about2: 'assets/about2.png',
                    about3: 'assets/about3.png', about4: 'assets/about4.png',
                    candle0: 'assets/candle0.png', candle1: 'assets/candle1.png', candle2: 'assets/candle2.png',
                    wood_texture: 'assets/wood_texture.jpg', marble_texture: 'assets/marble_texture.jpg',
                    plate1: 'assets/plate1.jpg', plate2: 'assets/plate2.jpg', plate3: 'assets/plate3.jpg',
                    plate4: 'assets/plate4.jpg', plate5: 'assets/plate5.jpg', plate6: 'assets/plate6.jpg',
                    BGM: 'assets/BGM.mp3', click: 'assets/click.mp3', shoot: 'assets/shoot.mp3',
                    collision: 'assets/collision.mp3', point: 'assets/point.mp3',
                    victory: 'assets/victory.mp3', notice: 'assets/notice.mp3',
                    roulette: 'assets/roulette.mp3', roulettedet: 'assets/roulettedet.mp3'
                };
                const assetPromises = Object.entries(assetPaths).map(([key, path]) => {
                    return new Promise((resolve, reject) => {
                        if (path.endsWith('.png') || path.endsWith('.jpg')) {
                            const img = new Image();
                            img.src = path;
                            img.onload = () => { this.assets[key] = img; resolve(); };
                            img.onerror = reject;
                        } else {
                            const audio = new Audio(path);
                            audio.oncanplaythrough = () => { this.assets[key] = audio; resolve(); };
                            audio.onerror = reject;
                        }
                    });
                });
                await Promise.all(assetPromises);
                this.assets.about_images = [this.assets.about1, this.assets.about2, this.assets.about3, this.assets.about4];
                this.assets.candle_images = { 0: this.assets.candle0, 1: this.assets.candle1, 2: this.assets.candle2 };
                this.assets.plate_textures = [this.assets.plate1, this.assets.plate2, this.assets.plate3, this.assets.plate4, this.assets.plate5, this.assets.plate6];
                this.assets.sounds = {
                     click: this.assets.click, shoot: this.assets.shoot, collision: this.assets.collision,
                     point: this.assets.point, victory: this.assets.victory, notice: this.assets.notice,
                     roulette: this.assets.roulette, roulettedet: this.assets.roulettedet
                };
            }

            play_sound(sound_name) {
                if (this.se_on) {
                    const sound = this.assets.sounds[sound_name];
                    sound.currentTime = 0;
                    sound.play();
                }
            }
            
            create_buttons() {
                this.title_buttons = {
                    start: new Button("Start Game", new Vector2(this.SCREEN_WIDTH / 2, this.SCREEN_HEIGHT / 2 + 100), "48px sans-serif", this.ctx),
                    how_to: new Button("How to Play", new Vector2(this.SCREEN_WIDTH / 2, this.SCREEN_HEIGHT / 2 + 150), "32px sans-serif", this.ctx),
                    about: new Button("About", new Vector2(this.SCREEN_WIDTH / 2, this.SCREEN_HEIGHT / 2 + 180), "32px sans-serif", this.ctx)
                };
                this.sound_buttons = {
                    bgm: new Button("BGM on", new Vector2(230, this.SCREEN_HEIGHT - 30), "24px sans-serif", this.ctx),
                    se: new Button("SE on", new Vector2(310, this.SCREEN_HEIGHT - 30), "24px sans-serif", this.ctx)
                };
                this.game_over_buttons = {
                    restart: new Button("Start next Game", new Vector2(this.SCREEN_WIDTH / 2, this.SCREEN_HEIGHT / 2 + 50), "32px sans-serif", this.ctx),
                    to_title: new Button("Return to Title", new Vector2(this.SCREEN_WIDTH / 2, this.SCREEN_HEIGHT / 2 + 100), "24px sans-serif", this.ctx)
                };
            }

            _setup_board() {
                this.plates = [];
                for (let i = 1; i <= 3; i++) this._place_randomly(1, i, this.assets.plate_textures[i - 1]);
                for (let i = 1; i <= 3; i++) this._place_randomly(2, i, this.assets.plate_textures[i - 1 + 3]);
            }

            _place_randomly(player, plate_id, texture) {
                const board_x = (this.SCREEN_WIDTH - this.BOARD_WIDTH) / 2;
                const board_y = (this.SCREEN_HEIGHT - this.BOARD_HEIGHT) / 2;
                const half_board = this.BOARD_WIDTH / 2;
                const x_range = (player === 1) ? [board_x, board_x + half_board] : [board_x + half_board, board_x + this.BOARD_WIDTH];
                while (true) {
                    const pos_x = Math.random() * (x_range[1] - x_range[0] - this.PLATE_SIZE) + x_range[0] + this.PLATE_SIZE / 2;
                    const pos_y = Math.random() * (this.BOARD_HEIGHT - this.PLATE_SIZE) + board_y + this.PLATE_SIZE / 2;
                    const angle = Math.random() * 90;
                    const temp_plate = new Plate(player, plate_id, pos_x, pos_y, texture, angle, this);
                    if (!this.plates.some(p => this.check_collision_sat(p, temp_plate)[0])) {
                        this.plates.push(temp_plate);
                        break;
                    }
                }
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('mousedown', e => {
                    this.isMouseDown = true;
                    this.handleMouseDown(e);
                });
                 this.canvas.addEventListener('mouseup', e => {
                    this.isMouseDown = false;
                    this.handleMouseUp(e);
                });
                this.canvas.addEventListener('mousemove', e => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mousePos.x = e.clientX - rect.left;
                    this.mousePos.y = e.clientY - rect.top;
                });
                this.canvas.addEventListener('mouseleave', e => {
                    if (this.isMouseDown) {
                        this.isMouseDown = false;
                        this.handleMouseUp(e);
                    }
                });
            }

            handleMouseDown(e) {
                const mouse_pos = this.mousePos.copy();
                const sound_button_active_states = ["TITLE_SCREEN", "ABOUT_PAGE_1", "ABOUT_PAGE_2", "ABOUT_PAGE_3", "ABOUT_PAGE_4", "PLAYER_TURN", "PLATES_MOVING", "CANDLE_ANIMATION", "GAME_OVER", "FIRST_PLAYER_ROULETTE", "SHOWING_ROULETTE_RESULT"];
                if (sound_button_active_states.includes(this.game_state)) {
                    if (this.sound_buttons.bgm.check_hover(mouse_pos)) {
                        this.bgm_on = !this.bgm_on;
                        this.sound_buttons.bgm.text = this.bgm_on ? "BGM on" : "BGM off";
                        if (this.bgm_on) { this.assets.BGM.play(); } else { this.assets.BGM.pause(); }
                        return;
                    }
                    if (this.sound_buttons.se.check_hover(mouse_pos)) {
                        this.se_on = !this.se_on;
                        this.sound_buttons.se.text = this.se_on ? "SE on" : "SE off";
                        return;
                    }
                }
                
                switch(this.game_state) {
                    case "TITLE_SCREEN":
                        if (this.title_buttons.start.check_hover(mouse_pos)) {
                            if (this.bgm_on) {
                                this.assets.BGM.play();
                            }
                            this.play_sound('click');
                            this.game_state = "FADE_OUT_FROM_TITLE";
                            this.fade_alpha = 0;
                        } else if (this.title_buttons.how_to.check_hover(mouse_pos)) {
                            this.play_sound('click'); this.game_state = "FADE_IN_ABOUT_2"; this.fade_alpha = 255;
                        } else if (this.title_buttons.about.check_hover(mouse_pos)) {
                            this.play_sound('click'); this.game_state = "FADE_IN_ABOUT_1"; this.fade_alpha = 255;
                        }
                        break;
                    case "ABOUT_PAGE_1":
                        this.play_sound('click'); this.game_state = "FADE_OUT_FROM_ABOUT_1"; this.fade_alpha = 0;
                        break;
                    case "ABOUT_PAGE_2":
                    case "ABOUT_PAGE_3":
                        const currentPage = parseInt(this.game_state.split('_')[2]);
                        this.play_sound('click');
                        this.game_state = `ABOUT_PAGE_${currentPage + 1}`;
                        break;
                    case "ABOUT_PAGE_4":
                        this.play_sound('click'); this.game_state = "FADE_OUT_FROM_ABOUT_4"; this.fade_alpha = 0;
                        break;
                    case "FIRST_PLAYER_ROULETTE":
                        this.play_sound('roulettedet');
                        this.current_player = (Math.floor(this.roulette_timer / 5) % 2 === 0) ? 1 : 2;
                        this.game_state = "SHOWING_ROULETTE_RESULT";
                        this.roulette_timer = 2 * this.FPS;
                        break;
                    case "PLAYER_TURN":
                        for (const plate of this.plates) {
                            if (plate.owner === this.current_player && plate.is_point_colliding(mouse_pos)) {
                                this.play_sound('click');
                                this.selected_plate = plate;
                                this.drag_start_pos = mouse_pos;
                                this.click_offset = mouse_pos.sub(plate.pos);
                                break;
                            }
                        }
                        break;
                    case "GAME_OVER":
                        if (this.game_over_buttons.to_title.check_hover(mouse_pos)) {
                            this.init_game_session();
                            this.game_state = "FADE_IN_TO_TITLE";
                            this.fade_alpha = 255;
                        } else {
                            this.reset_game_vars();
                            this.game_state = "FIRST_PLAYER_ROULETTE";
                            this.roulette_timer = 120;
                        }
                        break;
                }
            }
            
            handleMouseUp(e) {
                if (this.game_state === "PLAYER_TURN" && this.selected_plate) {
                    const force_vector = this.drag_start_pos.sub(this.mousePos);
                    if (force_vector.length() > 5) {
                        this.play_sound('shoot');
                        this.selected_plate.apply_force_and_torque(force_vector, this.click_offset);
                        this.game_state = "PLATES_MOVING";
                    }
                    this.selected_plate = null;
                    this.drag_start_pos = null;
                    this.click_offset = new Vector2(0, 0);
                }
            }

            update_game_state() {
                const stateActions = {
                    "FADE_IN_TO_TITLE": () => {
                        this.fade_alpha = Math.max(0, this.fade_alpha - this.TITLE_FADE_SPEED);
                        if (this.fade_alpha === 0) this.game_state = "TITLE_SCREEN";
                    },
                    "FADE_OUT_FROM_TITLE": () => {
                        this.fade_alpha = Math.min(255, this.fade_alpha + this.TITLE_FADE_SPEED);
                        if (this.fade_alpha === 255) { this.game_state = "FADE_IN_TO_ROULETTE"; }
                    },
                    "FADE_IN_ABOUT_1": () => {
                        this.fade_alpha = Math.max(0, this.fade_alpha - this.TITLE_FADE_SPEED);
                        if (this.fade_alpha === 0) this.game_state = "ABOUT_PAGE_1";
                    },
                     "FADE_IN_ABOUT_2": () => {
                        this.fade_alpha = Math.max(0, this.fade_alpha - this.TITLE_FADE_SPEED);
                        if (this.fade_alpha === 0) this.game_state = "ABOUT_PAGE_2";
                    },
                    "FADE_OUT_FROM_ABOUT_1": () => {
                        this.fade_alpha = Math.min(255, this.fade_alpha + this.TITLE_FADE_SPEED);
                        if (this.fade_alpha === 255) { this.game_state = "FADE_IN_TO_TITLE"; }
                    },
                    "FADE_OUT_FROM_ABOUT_4": () => {
                        this.fade_alpha = Math.min(255, this.fade_alpha + this.TITLE_FADE_SPEED);
                        if (this.fade_alpha === 255) { this.game_state = "FADE_IN_TO_TITLE"; }
                    },
                    "FADE_IN_TO_ROULETTE": () => {
                        this.fade_alpha = Math.max(0, this.fade_alpha - this.TITLE_FADE_SPEED);
                        if (this.fade_alpha === 0) {
                            this.game_state = "FIRST_PLAYER_ROULETTE";
                            this.roulette_timer = 120;
                        }
                    },
                    "FIRST_PLAYER_ROULETTE": () => {
                        this.roulette_timer--;
                        this.roulette_color = (Math.floor(this.roulette_timer / 5) % 2 === 0) ? this.PLAYER_1_COLOR : this.PLAYER_2_COLOR;
                        
                        this.roulette_sound_timer--;
                        if (this.roulette_sound_timer <= 0) {
                            this.play_sound('roulette');
                            this.roulette_sound_timer = 0.2 * this.FPS;
                        }

                        if (this.roulette_timer <= 0) {
                            this.play_sound('roulettedet');
                            this.current_player = Math.random() < 0.5 ? 1 : 2;
                            this.game_state = "SHOWING_ROULETTE_RESULT";
                            this.roulette_timer = 2 * this.FPS;
                        }
                    },
                    "SHOWING_ROULETTE_RESULT": () => {
                        this.roulette_timer--;
                        if (this.roulette_timer <= 0) {
                            this._setup_board();
                            this.start_turn_effects();
                            this.game_state = "PLAYER_TURN";
                        }
                    },
                    "PLATES_MOVING": () => {
                        for (let i = 0; i < 8; i++) {
                            this.plates.forEach(p => p.update());
                            this.resolve_collisions();
                        }
                        if (!this.plates.some(p => p.is_moving())) {
                            if (!this.evaluate_turn_end()) {
                                this.switch_player();
                                this.game_state = "PLAYER_TURN";
                            }
                        }
                    },
                    "CANDLE_ANIMATION": () => {
                        this.anim_progress += this.anim_speed;
                        this.score_popup_alpha = Math.max(0, 255 * (1.0 - this.anim_progress));

                        if (this.anim_progress >= 1.0) {
                            this.check_game_over();
                            if (this.game_state !== "GAME_OVER") {
                                this._setup_board();
                                this.switch_player();
                                this.game_state = "PLAYER_TURN";
                            }
                        } else {
                            this.candle_pos = this.anim_start_pos.lerp(this.anim_target_pos, this.anim_progress);
                            this.candle_alpha = 255 * (1 - this.anim_progress);
                        }
                    },
                };
                if (stateActions[this.game_state]) stateActions[this.game_state]();
            }

            resolve_collisions() {
                for (let i = 0; i < this.plates.length; i++) {
                    for (let j = i + 1; j < this.plates.length; j++) {
                        const p1 = this.plates[i];
                        const p2 = this.plates[j];
                        const [is_colliding, mtv, collision_point] = this.check_collision_sat(p1, p2);
                        if (is_colliding) {
                            // --- ▼▼▼ 変更点: 衝突音の再生を有効化 + クールダウン追加 ---
                            const now = performance.now();
                            if (now - this.last_collision_sound_time > 50) { // 50ms (0.05秒)のクールダウン
                                this.play_sound('collision');
                                this.last_collision_sound_time = now;
                            }
                            if (mtv.lengthSquared() === 0) continue;
                            p1.pos = p1.pos.sub(mtv.divide(2));
                            p2.pos = p2.pos.add(mtv.divide(2));
                            p1.update_corners(); p2.update_corners();
                            const n = mtv.normalize();
                            const rv = p2.vel.sub(p1.vel);
                            const vel_along_normal = rv.dot(n);
                            if (vel_along_normal > 0) continue;
                            const impulse_scalar = -(1 + this.COLLISION_ELASTICITY) * vel_along_normal / 2;
                            const impulse_vec = n.multiply(impulse_scalar);
                            const r1 = collision_point.sub(p1.pos);
                            const r2 = collision_point.sub(p2.pos);
                            p1.vel = p1.vel.sub(impulse_vec);
                            p2.vel = p2.vel.add(impulse_vec);
                            p1.angular_velocity -= r1.cross(impulse_vec) / this.PLATE_INERTIA;
                            p2.angular_velocity += r2.cross(impulse_vec) / this.PLATE_INERTIA;
                        }
                    }
                }
            }

            check_collision_sat(p1, p2) {
                const axes = [...this.get_axes(p1), ...this.get_axes(p2)];
                let min_overlap = Infinity;
                let mtv_axis = null;
                for (const axis of axes) {
                    const [proj1_min, proj1_max] = this.project(p1, axis);
                    const [proj2_min, proj2_max] = this.project(p2, axis);
                    const overlap = Math.min(proj1_max, proj2_max) - Math.max(proj1_min, proj2_min);
                    if (overlap < 0) return [false, null, null];
                    if (overlap < min_overlap) {
                        min_overlap = overlap;
                        mtv_axis = axis;
                    }
                }
                if (mtv_axis && mtv_axis.lengthSquared() > 0) {
                    let mtv = mtv_axis.normalize().multiply(min_overlap);
                    if (p2.pos.sub(p1.pos).dot(mtv) < 0) mtv = mtv.multiply(-1);
                    const collision_point = this.find_collision_point(p1, p2, mtv.normalize());
                    return [true, mtv, collision_point];
                }
                return [false, null, null];
            }

            find_collision_point(p1, p2, axis) {
                const verts1 = [...p1.corners].sort((a, b) => a.dot(axis) - b.dot(axis));
                const verts2 = [...p2.corners].sort((a, b) => a.dot(axis) - b.dot(axis));
                return verts1[verts1.length-1].add(verts2[0]).divide(2);
            }

            get_axes(plate) {
                const axes = [];
                for (let i = 0; i < plate.corners.length; i++) {
                    const p1 = plate.corners[i];
                    const p2 = plate.corners[(i + 1) % plate.corners.length];
                    const edge = p2.sub(p1);
                    if (edge.lengthSquared() > 0) {
                        axes.push(edge.rotate(90).normalize());
                    }
                }
                return axes;
            }

            project(plate, axis) {
                const dots = plate.corners.map(c => c.dot(axis));
                return [Math.min(...dots), Math.max(...dots)];
            }
            
            evaluate_turn_end() {
                const board_x = (this.SCREEN_WIDTH - this.BOARD_WIDTH) / 2;
                const board_y = (this.SCREEN_HEIGHT - this.BOARD_HEIGHT) / 2;
                const board_rect = { x: board_x, y: board_y, width: this.BOARD_WIDTH, height: this.BOARD_HEIGHT, left: board_x, right: board_x + this.BOARD_WIDTH };
                const out_of_bounds_plates = [];
                const plates_to_keep = [];
                for(const plate of this.plates) {
                    const is_out = !plate.corners.some(c => c.x >= board_rect.x && c.x <= board_rect.x + board_rect.width && c.y >= board_rect.y && c.y <= board_rect.y + board_rect.height);
                    if (is_out) {
                        out_of_bounds_plates.push(plate);
                    } else {
                        plates_to_keep.push(plate);
                    }
                }
                if (out_of_bounds_plates.length === 0) return false;

                const opponent = 3 - this.current_player;
                let points = 0, winning_player = 0;
                
                const opponentPlateKnockedOut = out_of_bounds_plates.some(p => p.owner === opponent);

                if (opponentPlateKnockedOut) {
                    this.scores[opponent] += 1;
                    points = 1;
                    winning_player = opponent;
                } else {
                    const goal_p1 = this.current_player === 1 && out_of_bounds_plates.some(p => {
                        if (p.owner !== 1) return false;
                        if (!p.corners.every(c => c.x > board_rect.right)) return false;
                        const p_min_y = Math.min(...p.corners.map(c => c.y));
                        const p_max_y = Math.max(...p.corners.map(c => c.y));
                        return p_max_y > board_rect.y && p_min_y < board_rect.y + board_rect.height;
                    });
                    const goal_p2 = this.current_player === 2 && out_of_bounds_plates.some(p => {
                        if (p.owner !== 2) return false;
                        if (!p.corners.every(c => c.x < board_rect.left)) return false;
                        const p_min_y = Math.min(...p.corners.map(c => c.y));
                        const p_max_y = Math.max(...p.corners.map(c => c.y));
                        return p_max_y > board_rect.y && p_min_y < board_rect.y + board_rect.height;
                    });

                    if (goal_p1 || goal_p2) {
                        this.scores[this.current_player] += 2;
                        points = 2;
                        winning_player = this.current_player;
                    } else {
                        this.scores[opponent] += 1;
                        points = 1;
                        winning_player = opponent;
                    }
                }
                
                this.play_sound('point');
                if (points === 2) {
                    setTimeout(() => this.play_sound('point'), 150);
                }

                this.score_popup_color = (winning_player === 1) ? this.PLAYER_1_COLOR : this.PLAYER_2_COLOR;
                const team_name = (winning_player === 1) ? "Blue" : "Red";
                this.score_popup_text = `${team_name} team got ${points} candle${points > 1 ? 's' : ''}`;
                this.anim_candle_img = this.assets.candle_images[points];
                
                if (this.anim_candle_img) {
                    this.game_state = "CANDLE_ANIMATION";
                    this.anim_start_pos = new Vector2(this.SCREEN_WIDTH / 2, this.SCREEN_HEIGHT / 2);
                    const target_x = (winning_player === 1) ? 240 : this.SCREEN_WIDTH - 260;
                    this.anim_target_pos = new Vector2(target_x, 60);
                    this.candle_pos = this.anim_start_pos.copy();
                    this.candle_alpha = 255; this.anim_progress = 0.0;
                    this.anim_speed = 1.0 / (this.FPS * 1.0);
                    this.score_popup_alpha = 255;
                } else {
                    this.check_game_over();
                     if (this.game_state !== "GAME_OVER") {
                        this._setup_board();
                        this.switch_player();
                        this.game_state = "PLAYER_TURN";
                    }
                }
                this.plates = plates_to_keep;
                return true;
            }
            
            switch_player() {
                this.current_player = 3 - this.current_player;
                this.play_sound('notice');
                this.start_turn_effects();
            }

            start_turn_effects() {
                this.plates.forEach(plate => {
                    if (plate.owner === this.current_player) {
                        plate.fading = 255;
                    }
                });
            }

            check_game_over() {
                if (Object.values(this.scores).some(s => s >= this.WINNING_SCORE)) {
                    this.game_state = "GAME_OVER";
                    if (!this.victory_sound_played) {
                        this.play_sound('victory');
                        this.victory_sound_played = true;
                    }
                }
            }

            draw() {
                this.ctx.fillStyle = this.BLACK;
                this.ctx.fillRect(0, 0, this.SCREEN_WIDTH, this.SCREEN_HEIGHT);
                
                const gameStateActions = {
                    "LOADING": () => {
                        this.ctx.fillStyle = this.WHITE;
                        this.ctx.font = "32px sans-serif";
                        this.ctx.textAlign = "center";
                        this.ctx.fillText("Loading Assets...", this.SCREEN_WIDTH / 2, this.SCREEN_HEIGHT / 2);
                    },
                    "FADE_OUT_FROM_TITLE": this.draw_fade_out_title.bind(this),
                    "FADE_IN_TO_ROULETTE": this.draw_fade_in_to_roulette.bind(this),
                    "FADE_IN_TO_TITLE": this.draw_fade_in_title.bind(this),
                    "FADE_IN_ABOUT_1": this.draw_fade_in_overlay.bind(this, 0),
                    "FADE_IN_ABOUT_2": this.draw_fade_in_overlay.bind(this, 1),
                    "FADE_OUT_FROM_ABOUT_1": this.draw_fade_out_overlay.bind(this, 0),
                    "FADE_OUT_FROM_ABOUT_4": this.draw_fade_out_overlay.bind(this, 3),
                    "TITLE_SCREEN": () => this.draw_title_and_about(),
                    "ABOUT_PAGE_1": () => this.draw_title_and_about(0),
                    "ABOUT_PAGE_2": () => this.draw_title_and_about(1),
                    "ABOUT_PAGE_3": () => this.draw_title_and_about(2),
                    "ABOUT_PAGE_4": () => this.draw_title_and_about(3),
                    "FIRST_PLAYER_ROULETTE": this.draw_roulette.bind(this),
                    "SHOWING_ROULETTE_RESULT": this.draw_roulette.bind(this),
                };
                if (gameStateActions[this.game_state]) {
                    gameStateActions[this.game_state]();
                } else {
                    this.draw_game_board();
                }
                if (this.game_state === "CANDLE_ANIMATION") {
                    this.draw_score_popup();
                }
                if (this.game_state === "GAME_OVER") {
                    this.draw_game_over();
                }
                
                const sound_button_visible_states = ["TITLE_SCREEN", "ABOUT_PAGE_1", "ABOUT_PAGE_2", "ABOUT_PAGE_3", "ABOUT_PAGE_4", "PLAYER_TURN", "PLATES_MOVING", "CANDLE_ANIMATION", "GAME_OVER", "FIRST_PLAYER_ROULETTE", "SHOWING_ROULETTE_RESULT"];
                if (sound_button_visible_states.includes(this.game_state)) {
                    this.draw_sound_buttons();
                }
            }

            draw_fade_effect(alpha) {
                this.ctx.save();
                this.ctx.globalAlpha = alpha / 255;
                this.ctx.fillStyle = this.BLACK;
                this.ctx.fillRect(0, 0, this.SCREEN_WIDTH, this.SCREEN_HEIGHT);
                this.ctx.restore();
            }
            draw_fade_out_title() { this.draw_title_and_about(); this.draw_fade_effect(this.fade_alpha); }
            draw_fade_in_to_roulette() { this.draw_game_board(); this.draw_fade_effect(this.fade_alpha); }
            draw_fade_in_title() { this.draw_title_and_about(); this.draw_fade_effect(this.fade_alpha); }
            
            draw_fade_in_overlay(imageIndex) {
                this.draw_title_and_about();
                this.ctx.save();
                this.ctx.globalAlpha = (255 - this.fade_alpha) / 255;
                this.ctx.drawImage(this.assets.about_images[imageIndex], this.CONTENT_X_OFFSET, 0, this.CONTENT_WIDTH, this.CONTENT_HEIGHT);
                this.ctx.restore();
            }
            draw_fade_out_overlay(imageIndex) {
                this.draw_title_and_about(imageIndex);
                this.draw_fade_effect(this.fade_alpha);
            }
            draw_title_and_about(pageIndex = -1) {
                const baseImage = (pageIndex === -1) ? this.assets.title_image : this.assets.about_images[pageIndex];
                this.ctx.drawImage(baseImage, this.CONTENT_X_OFFSET, 0, this.CONTENT_WIDTH, this.CONTENT_HEIGHT);
                if (this.game_state === "TITLE_SCREEN") {
                    Object.values(this.title_buttons).forEach(button => button.draw(this.mousePos));
                }
            }
            draw_roulette() {
                this.draw_game_board();
                this.ctx.save();
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                if (this.game_state === "FIRST_PLAYER_ROULETTE") {
                    this.ctx.font = "48px sans-serif";
                    this.ctx.fillStyle = this.roulette_color;
                    this.ctx.fillText("Click to determine first player...", this.SCREEN_WIDTH / 2, this.SCREEN_HEIGHT / 2);
                } else {
                    this.ctx.font = "48px sans-serif";
                    this.ctx.fillStyle = this.current_player === 1 ? this.PLAYER_1_COLOR : this.PLAYER_2_COLOR;
                    const teamName = this.current_player === 1 ? "Blue" : "Red";
                    this.ctx.fillText(`${teamName} team starts!`, this.SCREEN_WIDTH / 2, this.SCREEN_HEIGHT / 2);
                }
                this.ctx.restore();
                this.draw_ui();
            }

            draw_game_board() {
                this.ctx.drawImage(this.assets.wood_texture, this.CONTENT_X_OFFSET, 0, this.CONTENT_WIDTH, this.CONTENT_HEIGHT);
                const boardX = (this.SCREEN_WIDTH - this.BOARD_WIDTH) / 2;
                const boardY = (this.SCREEN_HEIGHT - this.BOARD_HEIGHT) / 2;
                this.ctx.drawImage(this.assets.marble_texture, boardX, boardY, this.BOARD_WIDTH, this.BOARD_HEIGHT);
                this.ctx.strokeStyle = this.WHITE; this.ctx.lineWidth = 2;
                this.ctx.beginPath(); this.ctx.moveTo(this.SCREEN_WIDTH / 2, boardY); this.ctx.lineTo(this.SCREEN_WIDTH / 2, boardY + this.BOARD_HEIGHT); this.ctx.stroke();
                this.ctx.strokeStyle = this.PLAYER_2_COLOR; this.ctx.lineWidth = 8;
                this.ctx.beginPath(); this.ctx.moveTo(boardX, boardY); this.ctx.lineTo(boardX, boardY + this.BOARD_HEIGHT); this.ctx.stroke();
                this.ctx.strokeStyle = this.PLAYER_1_COLOR; this.ctx.lineWidth = 8;
                this.ctx.beginPath(); this.ctx.moveTo(boardX + this.BOARD_WIDTH, boardY); this.ctx.lineTo(boardX + this.BOARD_WIDTH, boardY + this.BOARD_HEIGHT); this.ctx.stroke();
                this.plates.forEach(plate => plate.draw(this.ctx));
                if (this.selected_plate && this.drag_start_pos) {
                    this.ctx.strokeStyle = this.WHITE; this.ctx.lineWidth = 2;
                    this.ctx.beginPath(); this.ctx.moveTo(this.drag_start_pos.x, this.drag_start_pos.y); this.ctx.lineTo(this.mousePos.x, this.mousePos.y); this.ctx.stroke();
                }
                this.draw_ui();
            }

            draw_sound_buttons() {
                Object.values(this.sound_buttons).forEach(button => button.draw(this.mousePos));
            }

            draw_ui() {
                const ui_data = [
                    { id: 1, color: this.PLAYER_1_COLOR, pos: new Vector2(240, 60) },
                    { id: 2, color: this.PLAYER_2_COLOR, pos: new Vector2(this.SCREEN_WIDTH - 260, 60) }
                ];
                this.ctx.save();
                ui_data.forEach(data => {
                    const score = this.scores[data.id];
                    const candleImg = this.assets.candle_images[0];
                    const cx = data.pos.x, cy = data.pos.y;
                    this.ctx.drawImage(candleImg, cx - candleImg.width/2, cy - candleImg.height/2);
                    this.ctx.font = "32px sans-serif";
                    this.ctx.fillStyle = data.color;
                    this.ctx.textAlign = "left";
                    this.ctx.textBaseline = "middle";
                    this.ctx.fillText(score, cx + candleImg.width/2 - 40, cy + 25);
                });
                if (this.game_state === "PLAYER_TURN") {
                    const color = this.current_player === 1 ? this.PLAYER_1_COLOR : this.PLAYER_2_COLOR;
                    const name = this.current_player === 1 ? "Blue" : "Red";
                    this.ctx.font = "48px sans-serif";
                    this.ctx.fillStyle = color;
                    this.ctx.textAlign = "center";
                    this.ctx.textBaseline = "middle";
                    this.ctx.fillText(`${name}'s turn`, this.SCREEN_WIDTH / 2, 60);
                }
                this.ctx.restore();
            }
            
            draw_score_popup() {
                 if (this.game_state === "CANDLE_ANIMATION" && this.anim_candle_img) {
                    this.ctx.save();
                    this.ctx.globalAlpha = this.candle_alpha / 255;
                    const img = this.anim_candle_img;
                    this.ctx.drawImage(img, this.candle_pos.x - img.width / 2, this.candle_pos.y - img.height / 2);
                    this.ctx.restore();
                }
                if (this.score_popup_alpha > 0) {
                    this.ctx.save();
                    this.ctx.globalAlpha = this.score_popup_alpha / 255;
                    this.ctx.font = "48px sans-serif";
                    this.ctx.fillStyle = this.score_popup_color;
                    this.ctx.textAlign = "center";
                    this.ctx.textBaseline = "middle";
                    this.ctx.fillText(this.score_popup_text, this.SCREEN_WIDTH / 2, this.SCREEN_HEIGHT / 2 - 50);
                    this.ctx.restore();
                }
            }

            draw_game_over() {
                this.ctx.save();
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.SCREEN_WIDTH, this.SCREEN_HEIGHT);
                const winner = this.scores[1] >= this.WINNING_SCORE ? 1 : 2;
                const team_name = winner === 1 ? "Blue" : "Red";
                const color = winner === 1 ? this.PLAYER_1_COLOR : this.PLAYER_2_COLOR;
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.font = "48px sans-serif";
                this.ctx.fillStyle = color;
                this.ctx.fillText(`${team_name} team wins!`, this.SCREEN_WIDTH / 2, this.SCREEN_HEIGHT / 2);
                
                Object.values(this.game_over_buttons).forEach(button => button.draw(this.mousePos));
                this.ctx.restore();
            }

            gameLoop() {
                this.update_game_state();
                this.draw();
                requestAnimationFrame(this.gameLoop);
            }
        }

        // ----------------------------------------------------------------
        // --- Plate Class ---
        // ----------------------------------------------------------------
        class Plate {
            constructor(owner, plate_id, x, y, texture, angle, game) {
                this.game = game;
                this.owner = owner;
                this.id = plate_id;
                this.pos = new Vector2(x, y);
                this.vel = new Vector2(0, 0);
                this.angle = angle;
                this.angular_velocity = 0;
                this.size = this.game.PLATE_SIZE;
                this.original_image = texture;
                this.corners = [];
                this.update_corners();
                this.fading = 0;
                this.offscreenCanvas = document.createElement('canvas');
                this.offscreenCanvas.width = this.size;
                this.offscreenCanvas.height = this.size;
                this.offscreenCtx = this.offscreenCanvas.getContext('2d');
                this.offscreenCtx.drawImage(this.original_image, 0, 0, this.size, this.size);
            }

            update_corners() {
                const half_size = this.size / 2;
                const local_corners = [
                    new Vector2(-half_size, -half_size), new Vector2(half_size, -half_size),
                    new Vector2(half_size, half_size), new Vector2(-half_size, half_size)
                ];
                this.corners = local_corners.map(p => this.pos.add(p.rotate(-this.angle)));
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle * Math.PI / 180);
                ctx.drawImage(this.original_image, -this.size / 2, -this.size / 2, this.size, this.size);
                const color = (this.owner === 1) ? this.game.PLAYER_1_COLOR_RGB : this.game.PLAYER_2_COLOR_RGB;
                ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`;
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                if (this.fading > 0) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.fading / 255})`;
                    ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                    this.fading = Math.max(0, this.fading - (255 / this.game.FPS));
                }
                ctx.restore();
            }

            update() {
                if (this.is_moving()) {
                    this.pos = this.pos.add(this.vel);
                    this.angle = (this.angle + this.angular_velocity) % 360;
                    this.update_corners();
                    const board_x = (this.game.SCREEN_WIDTH - this.game.BOARD_WIDTH) / 2;
                    const board_y = (this.game.SCREEN_HEIGHT - this.game.BOARD_HEIGHT) / 2;
                    
                    const friction_margin = 1.2 * this.game.PLATE_SIZE; 
                    
                    const friction_area = {
                        left: board_x - friction_margin,
                        right: board_x + this.game.BOARD_WIDTH + friction_margin,
                        top: board_y - friction_margin,
                        bottom: board_y + this.game.BOARD_HEIGHT + friction_margin
                    };
                    const in_friction_area = this.pos.x > friction_area.left && this.pos.x < friction_area.right &&
                                           this.pos.y > friction_area.top && this.pos.y < friction_area.bottom;
                    const friction = in_friction_area ? this.game.FRICTION_X : this.game.SIDE_FRICTION;
                    this.vel.x *= friction;
                    this.vel.y *= friction;
                    this.angular_velocity *= this.game.ANGULAR_FRICTION;
                    if (this.vel.lengthSquared() < this.game.STOP_THRESHOLD ** 2) this.vel = new Vector2(0, 0);
                    if (Math.abs(this.angular_velocity) < this.game.ANGULAR_STOP_THRESHOLD) this.angular_velocity = 0;
                }
            }

            is_moving() {
                return this.vel.lengthSquared() > 0 || this.angular_velocity !== 0;
            }

            apply_force_and_torque(force_vector, offset_vector) {
                this.vel = force_vector.multiply(this.game.POWER_MULTIPLIER);
                this.angular_velocity -= offset_vector.cross(this.vel) * this.game.TORQUE_MULTIPLIER;
            }
            
            get_rect() {
                const xs = this.corners.map(c => c.x);
                const ys = this.corners.map(c => c.y);
                const minX = Math.min(...xs);
                const minY = Math.min(...ys);
                const maxX = Math.max(...xs);
                const maxY = Math.max(...ys);
                return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
            }

            is_point_colliding(point) {
                const rect = this.get_rect();
                if (point.x < rect.x || point.x > rect.x + rect.width || point.y < rect.y || point.y > rect.y + rect.height) {
                    return false;
                }
                const local_pos_rotated = point.sub(this.pos).rotate(this.angle);
                const local_x = Math.floor(local_pos_rotated.x + this.size / 2);
                const local_y = Math.floor(local_pos_rotated.y + this.size / 2);
                if (local_x < 0 || local_x >= this.size || local_y < 0 || local_y >= this.size) return false;
                const pixelData = this.offscreenCtx.getImageData(local_x, local_y, 1, 1).data;
                return pixelData[3] > 0;
            }
        }
        
        // ----------------------------------------------------------------
        // --- Button Class ---
        // ----------------------------------------------------------------
        class Button {
            constructor(text, pos, font, ctx, base_color = 'rgb(255,255,255)', hover_color = 'rgb(200,200,200)') {
                this.text = text;
                this.pos = pos;
                this.font = font;
                this.ctx = ctx;
                this.base_color = base_color;
                this.hover_color = hover_color;
                this.rect = null;
                this.update_rect();
            }

            update_rect() {
                this.ctx.font = this.font;
                const metrics = this.ctx.measureText(this.text);
                this.rect = {
                    width: metrics.width,
                    height: parseInt(this.font, 10),
                    x: this.pos.x - metrics.width / 2,
                    y: this.pos.y - parseInt(this.font, 10) / 2
                };
            }

            check_hover(mouse_pos) {
                if (!this.rect) return false;
                return mouse_pos.x >= this.rect.x && mouse_pos.x <= this.rect.x + this.rect.width &&
                       mouse_pos.y >= this.rect.y && mouse_pos.y <= this.rect.y + this.rect.height;
            }

            draw(mouse_pos) {
                this.ctx.save();
                this.ctx.font = this.font;
                this.ctx.fillStyle = this.check_hover(mouse_pos) ? this.hover_color : this.base_color;
                this.ctx.textAlign = "center";
                this.ctx.textBaseline = "middle";
                this.ctx.fillText(this.text, this.pos.x, this.pos.y);
                this.ctx.restore();
            }
        }

        // --- Game Initialization ---
        window.onload = () => {
            new SosGame('gameCanvas');
        };
    </script>
</body>

</html>
